### 魔法项链

#### 题目描述

 Flea 来找 Cricket 询问怎么给妹子制作项链。Cricket 给 Flea 提供了一个由小写字母组成的字符串作为制作项链的原材料。Flea 平时也会收集原料，因此有时会把新的材料（一个字符）加在原材料的末尾。

 Flea每次可以从这个字符串中选择一个子串，制作成一条项链。子串不能是空串。

 Flea 制作的项链长度都是偶数。由于 Flea 致力于成为一个魔法师，因此每条项链都带有一个魔力值——这条项链前半段和后半段的相似度。两个字符串的相似度定义为，将两个字符串从左到右逐位匹配后，字符相同的位数。例如，zrl 和 djl的相似度是 1，而 wangyuhan 和 wangyuzhong 的相似度是 6。

 Flea 只在妹子发出请求时为她制作项链。妹子的要求非常苛刻，她总是要求 Flea 为她制作特定魔力值的项链。

 Flea 想知道，每次妹子发出请求时，他有多少种方法为她制作项链。两种制作方法不同，当且仅当两个子串的起始位置和结束位置至少有一个不同。然而 Cricket 作为一只单身狗，无法预见 Flea 的妹子的各种奇怪的要求。因此这次 Flea 只能靠自己。

------

#### 输入

 第一行两个正整数 n 和 m，表示 Cricket 给 Flea 的原材料的长度，以及之后的操作总数。

 第二行一个长度为 n 的字符串 s，表示原材料。

 第三行至第 m+2 行，每行两个元素 type 和 c：

 若 type=1，则 c 为一个字符，表示 Flea在原材料的末尾加了一个小写字母 c；

 若 type=2，则 c 为一个整数，表示 Flea 的妹子想要魔力值为 c 的项链。

#### 输出

 对于每个 type=2 的操作，输出一行一个整数，表示 Flea 有多少种制作项链的方法。

------

#### 样例输入

```
6 6
aababa
2 1
1 b
2 3
2 2
1 c
2 1
```

#### 样例输出

```
3
0
3
4
```

#### 样例说明

 对应每一个输出，合法的方案分别是：

1. aa, aaba, aababa
2. “empty”
3. aaba, abab, baba
4. aa, aaba, babc, aababa

- **解题思路**

> 就是对于一个项链的字串，对应的匹配度是多少，我们在计算匹配度的时候要注意每一次遍历对齐后的数，我们向下计算的时候由于有重复的内容不需要继续计算，只需要借助前面相同的部分，相同部分不需要比较，类似于滑动窗口法



- **解题代码**

```c++
#include <iostream>
using namespace std;

int n, m, ans[30005], mem[30005];
char str[30005]; 

int main() {
	cin >> n >> m >> &str[1];
	//枚举长度 
	for (int i = 1; i <= n / 2; i++) {
		int same = 0;
		//计算魔力值 
		for (int j = 1, k = i + 1; j <= i; j++, k++) {
			if (str[j] == str[k]) {
				same++;
			} 
		}
		ans[same]++;//魔力值计入ans数组相应位置中去， 
		for (int j = 2; j + 2 * i - 1 <= n; j++) {
			if (str[j - 1] == str[j - 1 + i]) {
				same--;//如果最左边的不想等就减去一 
			}
			if (str[j + i - 1] == str[j + 2 * i - 1]) {
				same++;//如果第二个的最右边相等就加上一 
			}
			ans[same]++;
		} //类似于滑动窗口法，就是相同的地方不再进行计算 
		mem[i] = same;//记忆化当前字串匹配度多少 
	}
	//m次操作 
	for (int i = 0; i < m; i++) {
		int t;
		cin >> t;
		if (t == 2) {
			cin >> t;
			cout << ans[t] << endl;//如果是2直接输出魔力值即可 
			continue;
		} 
		char l;
		cin >> l;//如果是1，就在字符串后面再加上一个字符 
		str[++n] = l;
		if (n % 2 == 0) {//若加入后长度为偶数，则计算新长度字串 
			int same = 0, mid = n >> 1;
			for (int j = 1, k = 1 + mid; j <= mid; j++, k++) {
				//貌似就是把该序列从中间劈开，然后比较两个字串相似度 
				if (str[j] == str[k]) {
					same++;
				}
			}
			ans[same]++;
			mem[mid] = same;
		}
		//与上面类似是为了避免重复计算使用类似于滑动窗口法则 
		//将之前所有长度最后状态取出，向后移动 
		for (int j = 1; j <= (n - 1) >> 1; j++) {
			if (str[n - j - j] == str[n - j]) {
				mem[j]--;
			}
			if (str[n] == str[n - j]) {
				mem[j]++;
			}
			ans[mem[j]]++;
		}
	}
	return 0;
}
```

