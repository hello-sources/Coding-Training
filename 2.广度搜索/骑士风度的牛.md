### 骑士风度的牛

#### 题目描述

​		农民约翰有很多牛，他想交易其中一头被Don称为骑士的牛。这头牛有一个独一无二的超能力，在农场里像骑士一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x,y的坐标图来表示。

 		这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了骑士的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定骑士要想吃到草，至少需要跳多少次。骑士的位置用 K 来标记，障碍的位置用 ∗ 来标记，草的位置用 H 来标记。

------

#### 输入

 第一行输入两个数，表示农场的列数 (≤150) 和行数 (≤150)。

 接下来输入地图。

#### 输出

 一个数，表示跳跃的最小次数。

------

#### 样例输入

```
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
```

#### 样例输出

```
5
```

#### 数据规模与约定

 时间限制：1 s

 内存限制：256 M

 100% 的数据保证 地图大小 ≤150



- **解题思路**

> 广搜解决最短路径问题，方向数组不同，因为马走的方式问题。



- **解题代码**

``` c
#include <iostream>
#include <queue>
using namespace std;

struct node {
	int x, y, step;
};

int n, m;
char mmap[200][200];
//根据马走日的方向数组 
int dir[8][2] = {1, 2, 1, -2, 2, 1, 2, -1,
					-1, 2, -1, -2, -2, 1, -2, -1};


int main() {
	cin >> m >> n;
	queue<node> que;
	for (int i = 1; i <=n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> mmap[i][j];
			//判断骑士的位置然后入队操作 
			if (mmap[i][j] == 'K') {
				que.push({i, j, 0});
			}
		}
	} 
	//队列非空的时候，循环 
	while (!que.empty()) {
		node temp = que.front();
		que.pop();
		for (int i = 0; i < 8; i++) {
			int x = temp.x + dir[i][0];
			int y = temp.y + dir[i][1];
			if (x < 1 || y < 1 || x > n || y > m) continue;
			if (mmap[x][y] == 'H') {//找到终点就直接输出结果并且返回 
				cout << temp.step + 1 << endl;
				return 0;
			}
			//如果遇到点就表示没走过，标注为0，继续入队 
			if (mmap[x][y] == '.') {
				mmap[x][y] = 0;
				que.push({x, y, temp.step + 1});
			}
		}
	}	
	return 0;
} 
```

