### 瓷砖

- **题目描述**

 在一个 w∗h 的矩形广场上，每一块 1∗1 的地面都铺设了红色或黑色的瓷砖。小明现在站在某一块黑色的瓷砖上，他可以从此处出发，移动到上下左右四个相邻的且是黑色的瓷砖上。现在，他想知道，通过重复上述移动所能经过的黑色瓷砖数。

**输入**

 第一行两个正整数 h,w。（2≤h,w≤50）

 接下来输入一个二维字符矩阵，每个字符为 ".","#","@"，分别代表黑色瓷砖，红色瓷砖，初始位置。

**输出**

 输出一个整数，表示可以到达的瓷砖数。

**样例输入**

```
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
```

**样例输出**

```
59
```



- **解题思路**

> 正常的走地图的题目



- **解题代码**

``` c
#include <iostream>
using namespace std;

int h, w, sx, sy, cnt = 1;
char cp[55][55];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

int func(int x, int y) {
	for (int i = 0; i < 4; i++) {
		int tx = x + dir[i][0];
		int ty = y + dir[i][1];
		if (cp[tx][ty] == '.') {
			cp[tx][ty] = '^';
			if (func(tx, ty)) cnt++; 
		}
	}
	return cnt;
}

int main() {
	cin >> h >> w;
	for (int i = 1; i <= w; i++) {
		for (int j = 1; j <= h; j++) {
			cin >> cp[i][j];
			if (cp[i][j] == '@') {
				sx = i;
				sy = j;
			}
		}
	}
	cout << func(sx, sy) << endl;
	return 0;
} 
```

