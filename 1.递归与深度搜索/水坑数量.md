### 水坑数量

#### 题目描述

 2019 年 7 月 24 日晚，哈尔滨开始打雷，察觉到这一点的大 T 决定下班回家，在因为各种原因墨迹了几分钟后，在 19:56 分，他出发了，可是当他走出楼的时候，发现已经开始下雨了，于是他改变主意，打算打车回家，可是根本打不到车啊，雨越下越大，裤子都湿了，气的大 T 先去吃了个饭。吃完饭后，雨还下的很大，且路上已经出现了相当深的积水，他决定坐公交车回去。这时大 T 发现，公交站附近的道路形如一个 n×m的二维矩阵，有些格子有积水，而有些格子没有积水，且有积水的格子周围 8 格若也有积水，则它们为同一个水坑，现求整个道路上总共有多少水坑。

 彩蛋：事实上，大 T 想去的公交站周围只有一个水坑，且深度大于十厘米，并把公交站完全包围了起来，那天晚上他回家后，一个人默默地把衣服裤子洗了，并把鞋刷了，So sad

------

#### 输入

 第 11 行为两个正整数 n,m

 接下来 n 行，每行 m 个字符，字符只可能是 .. （代表道路）或者 # （代表水），字符之间没有空格。

#### 输出

 输出总水坑数。

------

#### 样例输入

```
6 7
.#..###
....###
.#.....
#.#.###
.#.....
#......
```

#### 样例输出

```
4
```

- **解题思路**

> 跟走地图类似的题目，只是根据题目需要定义八个方向的方向数组，且每一个位置只是使用一次，判断为#之后就把该位置设置为另外一个字符，然后再进行递归求解，同样的在主函数中，每一个位置只是使用一次，求出水坑数量，更新一下

- **解题代码**

```c
#include <iostream>
using namespace std;

int n, m, ans;
char mmap[2005][2005];
int dir[8][2] = {0, 1, 1, 0, 0, -1, -1, 0, 
				1, 1, 1, -1, -1, 1, -1, -1};

void func(int x, int y) {
	for (int i = 0; i < 8; i++) {
		int tx = x + dir[i][0];
		int ty = y + dir[i][1];
		if (mmap[tx][ty] == '#') {
			mmap[tx][ty] = '0';
			func(tx, ty);
		}
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> (&mmap[i][1]);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (mmap[i][j] == '#') {
				mmap[i][j] = '0';
				ans += 1;
				func(i, j);
			}
		}
	}
	cout << ans << endl;	
	return 0;
} 
```

