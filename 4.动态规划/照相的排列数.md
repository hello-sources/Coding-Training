### 照相的排列数

#### 题目描述

 有N个学生合影，战成左端对齐的kk排，每排分别有N1,N2,…,Nk 个人， 第一排站在最后面，第k排站在最前面。学生的身高互不相同，把他们从高到低依次标记为1,2,…,N. 在合影时要求每一排从左到右身高依次递减，每一列从后到前身高也递减，问一共有多少种安排合影位置的方案？(1≤N≤30,1≤k≤5）

------

#### 输入

 多组样例输入

 对于每组数据，第一行有一个整数k(k≤5)，代表所要排的队数。

 第二行k个由空格分开的整数，代表每排所要的学生人数。

 (各排所需要的人数之和N不超过30)

 当k等于0时结束输入。

#### 输出

 按题目描述输出。

#### 输入样例1

```
1
30
5
6 6 6 6 1
0
```

#### 输出样例1

```
1
2103447060
```

- **解题思路**

> ”我到哪里去“状态更新
>
> 状态定义可以定义为k维的状态数组
>
> 也可以定义为二维状态数组表示两行人，当新加入一个人的时候要判断是否比前一个人高且比上一队列的人高，我们使用了五维数组来处理，每一维度表示一行，在处理高维数组空间高占用的时候，我们可以根据每一维度占用长度乘起来，就是大概的占用空间大小，这样为了节省空间。然后根据行列大小进行处理即可，处理第一个值val然后比较放在那一列对应的方法总数是多少进行累加即可。

- **解题代码**

```c++
#include <iostream>
#include <cstring>  
using namespace std;
long long a[5];

long long solve(long long k) {
	long long a[5] = {0}, full_size = 1;
	for (long long i = 0; i < k; i++) {
		cin >> a[i];//每排人数 
		full_size *= (a[i] + 1); //计算五维数组大小，用人数连乘表示用于初始化五维数组 
	}
	long long f[a[0] + 1][a[1] + 1][a[2] + 1][a[3] + 1][a[4] + 1];//这样声明是为了减少空间支出 
	memset(f, 0, sizeof(long long) * full_size); 
	f[0][0][0][0][0] = 1;//初始化状态就是1 
	for (long long i1 = 0; i1 <= a[0]; i1++) {
	for (long long i2 = 0; i2 <= a[1]; i2++) {
	for (long long i3 = 0; i3 <= a[2]; i3++) {
	for (long long i4 = 0; i4 <= a[3]; i4++) {
	for (long long i5 = 0; i5 <= a[4]; i5++) {	
		//根据左到右身高依次递减每一列从后到前身高也递减可知 
		long long val = f[i1][i2][i3][i4][i5];
		if (i1 < a[0] && i1 >= i2 && i1 >= i4 && i1 >= i5) 
			f[i1 + 1][i2][i3][i4][i5] += val;
		if (i2 < a[1] && i2 >= i3 && i2 >= i4 && i2 >= i5) 
			f[i1][i2 + 1][i3][i4][i5] += val;
		if (i3 < a[2] && i3 >= i4 && i3 >= i5) 
			f[i1][i2][i3 + 1][i4][i5] += val;
		if (i4 < a[3] && i4 >= i5) 
			f[i1][i2][i3][i4 + 1][i5] += val;
		if (i5 < a[4]) 
			f[i1][i2][i3][i4][i5 + 1] += val;
	}}}}}
	cout << f[a[0]][a[1]][a[2]][a[3]][a[4]] << endl;
	return 0;
} 

int main() {
	long long k;
	while (cin >> k) {
		if (k == 0) break;
		solve(k);
	}
	return 0;
} 
```

