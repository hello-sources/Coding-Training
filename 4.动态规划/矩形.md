### 矩形

#### 题目描述

在一个黑白相间的矩形中，问有多少个全白色的子矩形。

## ![18475740.jpg](http://jisuanke.oss-cn-beijing.aliyuncs.com/19-1-11/18475740.jpg)

#### 输入

第一行输入两个数字 n,m（2≤n,m≤1000），代表矩形的长和宽。

接下来 n 行，每行 m 个数字，0 代表黑色格子，1 代表白色格子。

#### 输出

输出一个整数，代表全白色子矩形的数量，结果可能过大，输出时请对 100007取余。

------

#### 样例输入1

```
6 6
0 1 1 1 1 1
1 1 0 1 1 1
1 1 1 1 1 1
1 1 1 0 1 1
1 1 1 1 0 1
1 0 1 1 1 1
```

#### 样例输出1

```
152
```

------

#### 数据规模与约定

时间限制：1 s

内存限制：64 M

40% 的数据保证 n,m≤100

80% 的数据保证 n,m≤500

100% 的数据保证 n,m≤1000



- **解题思路**

> 把每一行对应位置抽象出为一个一维矩阵，每一个位置对应的白色格子数对应抽象为木板，就可以得到对应的状态转移方程f(i) = (j - i) * a(i) + f(j + 1),为此我们引入单调栈，每一行的元素进入单调栈中，统计好每一个位置的白色格子之后，对于数据根据状态转移方程进行处理

- **解题代码**

```c++
#include <iostream>
using namespace std;
#define MAX_N 1000
int f[MAX_N + 5];//记录当前位置的矩形的值 
int a[MAX_N + 5];//向上数连续白色格子的数量 
int s[MAX_N + 5], top = -1;//单调栈 

int main() {
	int n, m, ans = 0;
	cin >> n >> m;
	a[m + 1] = -1;
	f[m + 1] = 0;
	for (int i = 1; i <= n; i++) {
		//记录每一个位置的白色矩形的个数，读一行数据 
		for (int j = 1, val; j <= m; j++) {
			cin >> val;
			if (val == 1) a[j] += 1;
			else a[j] = 0; 
		}
		//读入一行之后对于每一行进行处理 
		top = -1;//单调栈每一次都得清空 
		s[++top] = m + 1;
		for (int j = m; j >= 1; j--) {
			while (a[s[top]] >= a[j]) top--;
			f[j] = (s[top] - j) * a[j] + f[s[top]];	
			//每一列位置可以抽象为一根木板，连续公共长度相等的木板加上对应之后值 
			f[j] %= 100007;
			s[++top] = j;
			ans += f[j];
			ans %= 100007;
		}
	}
	cout << ans << endl;
	return 0;
}
```

